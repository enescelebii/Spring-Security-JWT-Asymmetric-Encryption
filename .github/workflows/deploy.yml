name: Task Flows Pipeline
# When the trigger is, this workflow will run
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

# constants to be used in the workflow
env:
  APP_NAME: task-flows-app

# Jobs to be executed separate machine
jobs:
  tests:
    env:
      TZ: Europe/Berlin
    runs-on: ubuntu-latest
    name: Tests
    # Steps to be executed
    steps:
      # Checkout the code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      # Setup Java
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'corretto'
      # Cache Maven dependencies, local usage it is done by maven. we write for GitHub actions
      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{hashFiles('**/pom.xml')}}
          restore-keys: ${{ runner.os }}-m2

      # give permissions to mvnw
      - name: Permission for mvnw
        run: chmod +x ./mvnw

      # Run unit tests
      - name: Running Unit Tests
        run: |
          ./mvnw clean test

  build-and-deploy:
    runs-on: ubuntu-latest
    name: Build & Deploy
    # This job will not start until tests job is completed
    needs: tests
    if: github.ref == 'refs/heads/main'
    steps:
      # Checkout the code
      - name: Checkout code
        uses: actions/checkout@v4
      # Setup Java
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'corretto'
      # Cache Maven dependencies, local usage it is done by maven. we write for GitHub actions
      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{hashFiles('**/pom.xml')}}
          restore-keys: ${{ runner.os }}-m2

      - name: Extract project version
        id: extract_version
        # We use the maven exec plugin to extract the project version
        run: |
          echo "VERSION=$(./mvnw -q -Dexec.executable='echo' -Dexec.args='${project.version}' --non-recursive exec:exec)" >> $GITHUB_OUTPUT

      # give permissions to mvnw
      - name: Permission for mvnw
        run: chmod +x ./mvnw

      - name: Build application
        run: ./mvnw clean package -DskipTests

      # Build and push the Docker image with Buildx (don't push on PR)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Login to DockerHub
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with: # Use secrets from repository settings
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: . # dot means root directory
          pull: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.APP_NAME }}:${{ steps.extract_version.outputs.VERSION }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: | # We use build-args to set environment variables
            PROFILE=dev
            APP_VERSION=${{ steps.extract_version.outputs.VERSION }}

      # Deploy to VPS, SSH to deploy the application
      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT }}
          #  passphrase: ${{ secrets.VPS_SSH_KEY_PASSPHRASE }} we do not have a passphrase
          script: |
            # Navigate to app directory 
            cd /opt/${{ env.APP_NAME }} || mkdir -p /opt/${{ env.APP_NAME }} && cd /opt/${{ env.APP_NAME }}
            
            # Create .env file with environment variables
            cat > .env << EOF
            DOCKER_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
            APP_NAME=${{ env.APP_NAME }}
            DB_URL=spring_sec_asym_enc
            PG_DB_NAME=${{ secrets.PG_DB_NAME }}
            PG_USERNAME=${{ secrets.PG_DB_USERNAME }}
            PG_PASSWORD=${{ secrets.PG_DB_PASSWORD }}
            EOF
            
            rm -f docker-compose.dev.yml
            # Download docker-compose.dev.yml if it doesn't exist
            if [ ! -f docker-compose.dev.yml ]; then
              curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -L -o docker-compose.dev.yml https://raw.githubusercontent.com/${{ github.repository }}/refs/heads/main/docker-compose.dev.yml
            fi
            
            # Pull the latest image
            docker compose -f docker-compose.dev.yml --env-file .env pull
            
            # Stop and remove old containers
            docker compose -f docker-compose.dev.yml --env-file .env down
            
            # Start new containers
            docker compose -f docker-compose.dev.yml --env-file .env up -d
            
            # Clean up old images
            docker image prune -f
            
            
            
